const fs = require('fs');
const path = require('path');

const coreDir = path.join(__dirname, 'src', 'core');
const distDir = path.join(__dirname, 'dist');
if (!fs.existsSync(distDir)) fs.mkdirSync(distDir, { recursive: true });

const files = fs.readdirSync(coreDir).filter(f => f.endsWith('.js'));

// Read each core module, detect its exports and count requires to order bundling
const modules = files.map(file => {
  const filePath = path.join(coreDir, file);
  const rawContent = fs.readFileSync(filePath, 'utf8');
  const exportMatch = rawContent.match(/module\.exports\s*=\s*\{([^}]*)\}/);
  const exportKeys = exportMatch
    ? exportMatch[1].split(',').map(s => s.trim())
    : [];
  const requireMatches = rawContent.match(/require\(\s*['"]\.\/\w+['"]\s*\)/g) || [];
  const requireCount = requireMatches.length;
  return { file, rawContent, exportKeys, requireCount };
});

// Sort modules so dependencies (with fewer requires) come first
modules.sort((a, b) => a.requireCount - b.requireCount);

// Generate src/index.js from src/core components
const indexPath = path.join(__dirname, 'src', 'index.js');
const componentNames = files.map(f => path.basename(f, '.js'));
let indexLines = [];

indexLines.push('// Auto-generated by build.js. Do not edit.');
componentNames.forEach(name => {
  indexLines.push(`const ${name} = require('./core/${name}').main;`);
});

indexLines.push('', 'module.exports = {');
componentNames.forEach(name => {
  indexLines.push(`  ${name},`);
});
indexLines.push('};', '');

fs.writeFileSync(indexPath, indexLines.join('\n'));
console.log('Generated src/index.js');

// Generate standalone parser code from JISON grammar (embed at build time)
const { Parser: JisonParser } = require('jison');
const grammarText = fs.readFileSync(path.join(__dirname, 'klsh.jison'), 'utf8');
const fullParserCode = new JisonParser(grammarText).generate();
// Strip UMD/commonjs export wrapper if present
let parserCode = fullParserCode;
const exportIdx = fullParserCode.indexOf('if (typeof require');
if (exportIdx > 0) parserCode = fullParserCode.slice(0, exportIdx);

// Begin bundle output, embedding parser
let output = `(function(global) {
  var components = {};
  // embedded jison-generated parser
${parserCode.split('\n').map(line => '  ' + line).join('\n')}
  // component: parse_klsh
  components['parse_klsh'] = {
    parse: parser.parse.bind(parser),
    main: function main_parse_klsh({ args, stdin, env }) {
      const stderr = 'Not implemented\\n';
      const newEnv = Object.assign({}, env, { '?': 1 });
      return { stdout: '', stderr, env: newEnv };
    }
  };
`;

modules.forEach(({ file, rawContent, exportKeys }) => {
  const name = path.basename(file, '.js');
  // Remove module.exports assignment
  let content = rawContent.replace(/module\.exports\s*=\s*\{[^}]*\};?/, '');
  // Rename main to module name
  content = content.replace(/function\s+main/, `function ${name}`);
  // Replace requires to other core modules with component references
  content = content.replace(/require\(\s*['"]\.\/([\w-]+)['"]\s*\)/g, "components['$1']");
  // Wrap module code and assign exports
  output += `
  // component: ${name}
  (function() {
${content.split('\n').map(line => '    ' + line).join('\n')}
    components['${name}'] = { ${exportKeys.map(key => `${key}: ${key === 'main' ? name : key}`).join(', ')} };
  })();
`;
});

output += `
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = components;
  } else {
    global.klsh = components;
  }
})(typeof window !== 'undefined' ? window : this);
`;

fs.writeFileSync(path.join(distDir, 'klsh.js'), output);
console.log('Built dist/klsh.js');