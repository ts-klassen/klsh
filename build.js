const fs = require('fs');
const path = require('path');

const coreDir = path.join(__dirname, 'src', 'core');
const distDir = path.join(__dirname, 'dist');
if (!fs.existsSync(distDir)) fs.mkdirSync(distDir, { recursive: true });

const files = fs.readdirSync(coreDir).filter(f => f.endsWith('.js'));

// Read each core module, detect its exports and count requires to order bundling
const modules = files.map(file => {
  const filePath = path.join(coreDir, file);
  const rawContent = fs.readFileSync(filePath, 'utf8');
  const exportMatch = rawContent.match(/module\.exports\s*=\s*\{([^}]*)\}/);
  const exportKeys = exportMatch
    ? exportMatch[1].split(',').map(s => s.trim())
    : [];
  const requireMatches = rawContent.match(/require\(\s*['"]\.\/\w+['"]\s*\)/g) || [];
  const requireCount = requireMatches.length;
  return { file, rawContent, exportKeys, requireCount };
});

// Sort modules so dependencies (with fewer requires) come first
modules.sort((a, b) => a.requireCount - b.requireCount);

// Generate src/index.js from src/core components
const indexPath = path.join(__dirname, 'src', 'index.js');
const componentNames = files.map(f => path.basename(f, '.js'));
let indexLines = [];

indexLines.push('// Auto-generated by build.js. Do not edit.');
componentNames.forEach(name => {
  indexLines.push(`const ${name} = require('./core/${name}').main;`);
});

indexLines.push('', 'module.exports = {');
componentNames.forEach(name => {
  indexLines.push(`  ${name},`);
});
indexLines.push('};', '');

fs.writeFileSync(indexPath, indexLines.join('\n'));
console.log('Generated src/index.js');

// Begin bundle output
// Embed all parsers defined in src/parser
const { Parser: JisonParser } = require('jison');
const parserDir = path.join(__dirname, 'src', 'parser');
const parserFiles = fs.existsSync(parserDir)
  ? fs.readdirSync(parserDir).filter(f => f.endsWith('.jison'))
  : [];
let output = `(function(global) {
  var components = {};
  components['parser'] = {};
`;
// For each grammar, generate a standalone parser and attach to components.parser
parserFiles.forEach(file => {
  const name = path.basename(file, '.jison');
  const grammar = fs.readFileSync(path.join(parserDir, file), 'utf8');
  const fullCode = new JisonParser(grammar).generate();
  // strip CommonJS exports wrapper if any
  let code = fullCode;
  const idx = fullCode.indexOf('if (typeof require');
  if (idx > 0) code = fullCode.slice(0, idx);
  // indent and declare parser
  output += `  // parser: ${name}\n`;
  output += code.split('\n').map(line => '  ' + line).join('\n') + '\n';
  output += `  components['parser']['${name}'] = parser.parse.bind(parser);\n`;
});

modules.forEach(({ file, rawContent, exportKeys }) => {
  const name = path.basename(file, '.js');
  // Remove module.exports assignment
  let content = rawContent.replace(/module\.exports\s*=\s*\{[^}]*\};?/, '');
  // Rename main to module name
  content = content.replace(/function\s+main/, `function ${name}`);
  // Replace requires to other core modules with component references
  content = content.replace(/require\(\s*['"]\.\/([\w-]+)['"]\s*\)/g, "components['$1']");
  // Wrap module code and assign exports
  output += `
  // component: ${name}
  (function() {
${content.split('\n').map(line => '    ' + line).join('\n')}
    components['${name}'] = { ${exportKeys.map(key => `${key}: ${key === 'main' ? name : key}`).join(', ')} };
  })();
`;
});

output += `
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = components;
  } else {
    global.klsh = components;
  }
})(typeof window !== 'undefined' ? window : this);
`;

fs.writeFileSync(path.join(distDir, 'klsh.js'), output);
console.log('Built dist/klsh.js');